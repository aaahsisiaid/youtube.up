<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>youtube.up - YouTube Video Uploader</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ffmpeg/0.12.6/ffmpeg.min.js"></script>
</head>
<body class="bg-gray-100 min-h-screen">
    <!-- Header -->
    <header class="bg-red-600 text-white p-4 shadow-lg">
        <div class="container mx-auto flex justify-between items-center">
            <h1 class="text-2xl font-bold">youtube.up</h1>
            <div class="flex items-center space-x-4">
                <div id="auth-status" class="text-sm"></div>
                <button id="auth-button" class="bg-white text-red-600 px-4 py-2 rounded hover:bg-gray-100 transition-colors">
                    Sign In
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto p-6">
        <!-- Upload Section -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h2 class="text-xl font-semibold mb-4">Upload Videos/Audio</h2>
            
            <!-- File Selection -->
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">
                    Select Files (MP4, MP3, WAV)
                </label>
                <input type="file" id="file-input" multiple accept=".mp4,.mp3,.wav" 
                       class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-red-50 file:text-red-700 hover:file:bg-red-100">
                <p class="text-sm text-gray-500 mt-1">Max 128MB per video, 2MB per thumbnail</p>
            </div>

            <!-- Batch Settings -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Title Template</label>
                    <input type="text" id="title-template" placeholder="{filename} #{index}" 
                           class="w-full p-2 border border-gray-300 rounded-md focus:ring-red-500 focus:border-red-500">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Privacy</label>
                    <select id="privacy-setting" class="w-full p-2 border border-gray-300 rounded-md focus:ring-red-500 focus:border-red-500">
                        <option value="private">Private</option>
                        <option value="unlisted">Unlisted</option>
                        <option value="public">Public</option>
                    </select>
                </div>
            </div>

            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">Description</label>
                <textarea id="description" rows="3" 
                          class="w-full p-2 border border-gray-300 rounded-md focus:ring-red-500 focus:border-red-500"
                          placeholder="Video description..."></textarea>
            </div>

            <!-- Playlist Settings -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Add to Playlist</label>
                    <select id="playlist-select" class="w-full p-2 border border-gray-300 rounded-md focus:ring-red-500 focus:border-red-500">
                        <option value="">Select playlist...</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Or Create New</label>
                    <input type="text" id="new-playlist-name" placeholder="New playlist name" 
                           class="w-full p-2 border border-gray-300 rounded-md focus:ring-red-500 focus:border-red-500">
                </div>
            </div>

            <!-- Thumbnail Upload -->
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">Thumbnail (Optional)</label>
                <input type="file" id="thumbnail-input" accept="image/*" 
                       class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-red-50 file:text-red-700 hover:file:bg-red-100">
            </div>

            <!-- Upload Button -->
            <button id="upload-button" class="w-full bg-red-600 text-white py-3 px-4 rounded-md hover:bg-red-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                Start Upload
            </button>
        </div>

        <!-- Progress Section -->
        <div id="progress-section" class="bg-white rounded-lg shadow-md p-6 hidden">
            <h2 class="text-xl font-semibold mb-4">Upload Progress</h2>
            <div id="progress-container"></div>
        </div>

        <!-- File List -->
        <div id="file-list" class="bg-white rounded-lg shadow-md p-6 hidden">
            <h2 class="text-xl font-semibold mb-4">Selected Files</h2>
            <div id="file-items"></div>
        </div>
    </main>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg">
            <div class="flex items-center space-x-3">
                <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-red-600"></div>
                <span>Initializing...</span>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let isAuthenticated = false;
        let ffmpegInstance = null;
        let selectedFiles = [];
        let uploadQueue = [];

        // Google API Configuration
        const API_KEY = 'AIzaSyBuV5V7kB3lI8EQtuQ7qB3q8J7QBkQjaM';
        const CLIENT_ID = '320694443306-u0g4k8vc7v6a3e2calbcq7r7jl40bqc4p.apps.googleusercontent.com';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/youtube/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/youtube.upload https://www.googleapis.com/auth/youtube';

        // DOM Elements
        const authButton = document.getElementById('auth-button');
        const authStatus = document.getElementById('auth-status');
        const fileInput = document.getElementById('file-input');
        const uploadButton = document.getElementById('upload-button');
        const progressSection = document.getElementById('progress-section');
        const fileList = document.getElementById('file-list');
        const loadingOverlay = document.getElementById('loading-overlay');

        // Initialize application
        async function initApp() {
            console.log('Initializing application...');
            showLoading(true);
            
            try {
                await initGapiClient();
                await initFFmpeg();
                setupEventListeners();
                console.log('Application initialized successfully');
            } catch (error) {
                console.error('Failed to initialize application:', error);
                alert('Failed to initialize. Please refresh the page.');
            } finally {
                showLoading(false);
            }
        }

        // Initialize Google API Client with retry mechanism
        async function initGapiClient(retries = 3) {
            console.log('Initializing Google API Client...');
            
            return new Promise((resolve, reject) => {
                const attemptInit = async (attempt) => {
                    try {
                        if (!window.gapi) {
                            throw new Error('Google API not loaded');
                        }

                        gapi.load('auth2:client', {
                            callback: async () => {
                                try {
                                    await gapi.client.init({
                                        apiKey: API_KEY,
                                        clientId: CLIENT_ID,
                                        discoveryDocs: [DISCOVERY_DOC],
                                        scope: SCOPES
                                    });

                                    // Check if user is already signed in
                                    const authInstance = gapi.auth2.getAuthInstance();
                                    if (authInstance.isSignedIn.get()) {
                                        handleAuthSuccess();
                                    }

                                    console.log('Google API Client initialized successfully');
                                    resolve();
                                } catch (error) {
                                    console.error(`GAPI client init failed (attempt ${attempt}):`, error);
                                    if (attempt < retries) {
                                        setTimeout(() => attemptInit(attempt + 1), 1000 * attempt);
                                    } else {
                                        reject(error);
                                    }
                                }
                            },
                            onerror: (error) => {
                                console.error(`GAPI load failed (attempt ${attempt}):`, error);
                                if (attempt < retries) {
                                    setTimeout(() => attemptInit(attempt + 1), 1000 * attempt);
                                } else {
                                    reject(error);
                                }
                            }
                        });
                    } catch (error) {
                        console.error(`Init attempt ${attempt} failed:`, error);
                        if (attempt < retries) {
                            setTimeout(() => attemptInit(attempt + 1), 1000 * attempt);
                        } else {
                            reject(error);
                        }
                    }
                };

                attemptInit(1);
            });
        }

        // Initialize FFmpeg with retry mechanism
        async function initFFmpeg(retries = 3) {
            console.log('Initializing FFmpeg...');
            
            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    if (typeof FFmpeg === 'undefined') {
                        throw new Error('FFmpeg not loaded');
                    }

                    ffmpegInstance = new FFmpeg.FFmpeg();
                    
                    ffmpegInstance.on('log', ({ message }) => {
                        console.log('FFmpeg:', message);
                    });

                    ffmpegInstance.on('progress', ({ progress }) => {
                        console.log(`FFmpeg progress: ${Math.round(progress * 100)}%`);
                    });

                    await ffmpegInstance.load();
                    console.log('FFmpeg initialized successfully');
                    return;
                } catch (error) {
                    console.error(`FFmpeg init failed (attempt ${attempt}):`, error);
                    if (attempt === retries) {
                        console.warn('FFmpeg initialization failed. Audio conversion will not be available.');
                        ffmpegInstance = null;
                    } else {
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                    }
                }
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            authButton.addEventListener('click', handleAuthClick);
            fileInput.addEventListener('change', handleFileSelection);
            uploadButton.addEventListener('click', handleUpload);
            
            // Playlist creation
            document.getElementById('new-playlist-name').addEventListener('input', function() {
                if (this.value.trim()) {
                    document.getElementById('playlist-select').value = '';
                }
            });

            console.log('Event listeners setup complete');
        }

        // Handle authentication click
        async function handleAuthClick() {
            console.log('handleAuthClick called');
            
            try {
                if (!gapi.auth2) {
                    throw new Error('Google Auth not initialized');
                }

                const authInstance = gapi.auth2.getAuthInstance();
                
                if (isAuthenticated) {
                    // Sign out
                    await authInstance.signOut();
                    handleAuthSuccess(false);
                } else {
                    // Sign in
                    const user = await authInstance.signIn();
                    handleAuthSuccess(true);
                }
            } catch (error) {
                console.error('Authentication error:', error);
                alert('Authentication failed. Please try again.');
            }
        }

        // Handle authentication success/failure
        function handleAuthSuccess(signedIn = true) {
            isAuthenticated = signedIn;
            
            if (signedIn) {
                const user = gapi.auth2.getAuthInstance().currentUser.get();
                const profile = user.getBasicProfile();
                
                authStatus.textContent = `Signed in as ${profile.getName()}`;
                authButton.textContent = 'Sign Out';
                authButton.classList.remove('bg-white', 'text-red-600');
                authButton.classList.add('bg-red-700', 'text-white');
                
                loadPlaylists();
            } else {
                authStatus.textContent = '';
                authButton.textContent = 'Sign In';
                authButton.classList.remove('bg-red-700', 'text-white');
                authButton.classList.add('bg-white', 'text-red-600');
                
                // Clear playlist dropdown
                const playlistSelect = document.getElementById('playlist-select');
                playlistSelect.innerHTML = '<option value="">Select playlist...</option>';
            }
        }

        // Load user's playlists
        async function loadPlaylists() {
            try {
                const response = await gapi.client.youtube.playlists.list({
                    part: 'snippet',
                    mine: true,
                    maxResults: 50
                });

                const playlistSelect = document.getElementById('playlist-select');
                playlistSelect.innerHTML = '<option value="">Select playlist...</option>';

                response.result.items.forEach(playlist => {
                    const option = document.createElement('option');
                    option.value = playlist.id;
                    option.textContent = playlist.snippet.title;
                    playlistSelect.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load playlists:', error);
            }
        }

        // Handle file selection
        function handleFileSelection(event) {
            selectedFiles = Array.from(event.target.files);
            displayFileList();
            
            if (selectedFiles.length > 0) {
                fileList.classList.remove('hidden');
                uploadButton.disabled = false;
            } else {
                fileList.classList.add('hidden');
                uploadButton.disabled = true;
            }
        }

        // Display selected files
        function displayFileList() {
            const fileItems = document.getElementById('file-items');
            fileItems.innerHTML = '';

            selectedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'flex items-center justify-between p-3 border rounded-lg mb-2';
                
                const fileInfo = document.createElement('div');
                fileInfo.innerHTML = `
                    <div class="font-medium">${file.name}</div>
                    <div class="text-sm text-gray-500">
                        ${(file.size / (1024 * 1024)).toFixed(2)} MB - ${file.type}
                    </div>
                `;
                
                const removeButton = document.createElement('button');
                removeButton.className = 'text-red-600 hover:text-red-800';
                removeButton.textContent = 'Remove';
                removeButton.onclick = () => removeFile(index);
                
                fileItem.appendChild(fileInfo);
                fileItem.appendChild(removeButton);
                fileItems.appendChild(fileItem);
            });
        }

        // Remove file from selection
        function removeFile(index) {
            selectedFiles.splice(index, 1);
            displayFileList();
            
            if (selectedFiles.length === 0) {
                fileList.classList.add('hidden');
                uploadButton.disabled = true;
            }
        }

        // Handle upload process
        async function handleUpload() {
            if (!isAuthenticated) {
                alert('Please sign in first');
                return;
            }

            if (selectedFiles.length === 0) {
                alert('Please select files to upload');
                return;
            }

            uploadButton.disabled = true;
            progressSection.classList.remove('hidden');

            try {
                // Create playlist if specified
                let playlistId = document.getElementById('playlist-select').value;
                const newPlaylistName = document.getElementById('new-playlist-name').value.trim();
                
                if (newPlaylistName) {
                    playlistId = await createPlaylist(newPlaylistName);
                }

                // Process each file
                for (let i = 0; i < selectedFiles.length; i++) {
                    await processFile(selectedFiles[i], i + 1, playlistId);
                }

                alert('All uploads completed successfully!');
            } catch (error) {
                console.error('Upload process failed:', error);
                alert('Upload failed: ' + error.message);
            } finally {
                uploadButton.disabled = false;
            }
        }

        // Process individual file
        async function processFile(file, index, playlistId) {
            const progressId = `progress-${index}`;
            addProgressItem(progressId, file.name, index);

            try {
                let videoFile = file;

                // Convert audio to video if needed
                if (file.type.startsWith('audio/')) {
                    updateProgress(progressId, 'Converting audio to video...', 0);
                    videoFile = await convertAudioToVideo(file, progressId);
                }

                // Upload video
                updateProgress(progressId, 'Uploading video...', 0);
                const videoId = await uploadVideo(videoFile, index, progressId);

                // Upload thumbnail if provided
                const thumbnailFile = document.getElementById('thumbnail-input').files[0];
                if (thumbnailFile) {
                    updateProgress(progressId, 'Uploading thumbnail...', 90);
                    await uploadThumbnail(videoId, thumbnailFile);
                }

                // Add to playlist if specified
                if (playlistId) {
                    updateProgress(progressId, 'Adding to playlist...', 95);
                    await addToPlaylist(playlistId, videoId);
                }

                updateProgress(progressId, 'Completed', 100);
            } catch (error) {
                updateProgress(progressId, `Error: ${error.message}`, 0);
                throw error;
            }
        }

        // Convert audio to video using FFmpeg
        async function convertAudioToVideo(audioFile, progressId) {
            if (!ffmpegInstance) {
                throw new Error('FFmpeg not available for audio conversion');
            }

            try {
                const audioData = new Uint8Array(await audioFile.arrayBuffer());
                await ffmpegInstance.writeFile('input.mp3', audioData);

                await ffmpegInstance.exec([
                    '-f', 'lavfi',
                    '-i', 'color=c=black:s=1280x720:d=1',
                    '-i', 'input.mp3',
                    '-c:v', 'libx264',
                    '-c:a', 'aac',
                    '-shortest',
                    '-y',
                    'output.mp4'
                ]);

                const videoData = await ffmpegInstance.readFile('output.mp4');
                const videoBlob = new Blob([videoData.buffer], { type: 'video/mp4' });
                
                return new File([videoBlob], audioFile.name.replace(/\.[^/.]+$/, '.mp4'), {
                    type: 'video/mp4'
                });
            } catch (error) {
                console.error('Audio conversion failed:', error);
                throw new Error('Failed to convert audio to video');
            }
        }

        // Upload video to YouTube
        async function uploadVideo(file, index, progressId) {
            const titleTemplate = document.getElementById('title-template').value || '{filename} #{index}';
            const title = titleTemplate
                .replace('{filename}', file.name.replace(/\.[^/.]+$/, ''))
                .replace('{index}', index);
            
            const description = document.getElementById('description').value || '';
            const privacy = document.getElementById('privacy-setting').value;

            const metadata = {
                snippet: {
                    title: title,
                    description: description,
                    categoryId: '22' // People & Blogs
                },
                status: {
                    privacyStatus: privacy
                }
            };

            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                const formData = new FormData();
                
                formData.append('metadata', new Blob([JSON.stringify(metadata)], {
                    type: 'application/json'
                }));
                formData.append('media', file);

                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const progress = Math.round((e.loaded / e.total) * 85); // Reserve 15% for post-processing
                        updateProgress(progressId, 'Uploading...', progress);
                    }
                });

                xhr.addEventListener('load', () => {
                    if (xhr.status === 200) {
                        try {
                            const response = JSON.parse(xhr.responseText);
                            resolve(response.id);
                        } catch (error) {
                            reject(new Error('Invalid response format'));
                        }
                    } else {
                        reject(new Error(`Upload failed: ${xhr.status} ${xhr.statusText}`));
                    }
                });

                xhr.addEventListener('error', () => {
                    reject(new Error('Upload failed: Network error'));
                });

                const accessToken = gapi.auth2.getAuthInstance().currentUser.get().getAuthResponse().access_token;
                
                xhr.open('POST', 'https://www.googleapis.com/upload/youtube/v3/videos?uploadType=multipart&part=snippet,status');
                xhr.setRequestHeader('Authorization', `Bearer ${accessToken}`);
                xhr.send(formData);
            });
        }

        // Upload thumbnail
        async function uploadThumbnail(videoId, thumbnailFile) {
            if (thumbnailFile.size > 2 * 1024 * 1024) {
                throw new Error('Thumbnail file size must be less than 2MB');
            }

            const accessToken = gapi.auth2.getAuthInstance().currentUser.get().getAuthResponse().access_token;

            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                
                xhr.addEventListener('load', () => {
                    if (xhr.status === 200) {
                        resolve();
                    } else {
                        reject(new Error(`Thumbnail upload failed: ${xhr.status}`));
                    }
                });

                xhr.addEventListener('error', () => {
                    reject(new Error('Thumbnail upload failed'));
                });

                xhr.open('POST', `https://www.googleapis.com/upload/youtube/v3/thumbnails/set?videoId=${videoId}`);
                xhr.setRequestHeader('Authorization', `Bearer ${accessToken}`);
                xhr.setRequestHeader('Content-Type', thumbnailFile.type);
                xhr.send(thumbnailFile);
            });
        }

        // Create playlist
        async function createPlaylist(name) {
            try {
                const response = await gapi.client.youtube.playlists.insert({
                    part: 'snippet,status',
                    resource: {
                        snippet: {
                            title: name,
                            description: `Created by youtube.up on ${new Date().toLocaleDateString()}`
                        },
                        status: {
                            privacyStatus: 'private'
                        }
                    }
                });

                return response.result.id;
            } catch (error) {
                console.error('Failed to create playlist:', error);
                throw new Error('Failed to create playlist');
            }
        }

        // Add video to playlist
        async function addToPlaylist(playlistId, videoId) {
            try {
                await gapi.client.youtube.playlistItems.insert({
                    part: 'snippet',
                    resource: {
                        snippet: {
                            playlistId: playlistId,
                            resourceId: {
                                kind: 'youtube#video',
                                videoId: videoId
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Failed to add video to playlist:', error);
                throw new Error('Failed to add video to playlist');
            }
        }

        // Progress management
        function addProgressItem(id, filename, index) {
            const progressContainer = document.getElementById('progress-container');
            const progressItem = document.createElement('div');
            progressItem.id = id;
            progressItem.className = 'mb-4 p-4 border rounded-lg';
            progressItem.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <span class="font-medium">${filename}</span>
                    <span class="text-sm text-gray-500">#${index}</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2">
                    <div class="bg-red-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <div class="text-sm text-gray-600 mt-1">Preparing...</div>
            `;
            progressContainer.appendChild(progressItem);
        }

        function updateProgress(id, status, percentage) {
            const progressItem = document.getElementById(id);
            if (progressItem) {
                const progressBar = progressItem.querySelector('.bg-red-600');
                const statusText = progressItem.querySelector('.text-gray-600');
                
                progressBar.style.width = `${percentage}%`;
                statusText.textContent = `${status} ${percentage > 0 ? `(${percentage}%)` : ''}`;
                
                if (percentage === 100) {
                    statusText.classList.remove('text-gray-600');
                    statusText.classList.add('text-green-600');
                }
            }
        }

        function showLoading(show) {
            if (show) {
                loadingOverlay.classList.remove('hidden');
            } else {
                loadingOverlay.classList.add('hidden');
            }
        }

        // Make handleAuthClick globally available
        window.handleAuthClick = handleAuthClick;

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing app...');
            initApp();
        });

        // Handle page visibility for auth state
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && gapi.auth2) {
                const authInstance = gapi.auth2.getAuthInstance();
                if (authInstance.isSignedIn.get() !== isAuthenticated) {
                    handleAuthSuccess(authInstance.isSignedIn.get());
                }
            }
        });
    </script>
</body>
</html>
